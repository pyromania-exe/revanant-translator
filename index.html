<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Revanant Code Hub (Full Rules)</title>
  <style>
    body { background:#0d0d0d; color:#e0e0e0; font-family:monospace; padding:2rem; line-height:1.6; }
    h1 { color:#7c4dff; }
    select, textarea, button { font-family:monospace; font-size:1rem; border-radius:6px; padding:.6rem; }
    select, textarea { background:#1a1a1a; color:#e0e0e0; border:none; }
    textarea { width:100%; min-height:120px; margin-top:.5rem; }
    button { margin-top:1rem; background:#7c4dff; color:white; border:none; font-weight:bold; cursor:pointer; }
    pre { margin-top:1rem; background:#111; padding:1rem; border-radius:6px; white-space:pre-wrap; }
    .section { margin-top:2rem; padding:1rem; background:#1a1a1a; border-radius:8px; }
    code { background:#222; padding:2px 4px; border-radius:4px; color:#3ddc97; }
  </style>
</head>
<body>
  <h1>Revanant Code Translator (Full Rules)</h1>
  <label for="mode">Choose mode:</label>
  <select id="mode">
    <option value="englishToRevan">English → Revanant</option>
    <option value="revanToEnglish">Revanant → English</option>
  </select>

  <textarea id="input" placeholder="Type text here..."></textarea>
  <button id="translateBtn">Translate</button>
  <pre id="output"></pre>

  <div class="section">
    <h2>Revanant Code – Rulebook</h2>
    <h3>Phonology</h3>
    <ul>
      <li>Vowel mutation: <code>a→au</code>, <code>e→ei</code>, <code>i→oi</code>, <code>o→ou</code>, <code>u→uu</code></li>
    </ul>
    <h3>Syntax</h3>
    <ul>
      <li>Word order: OVS (Object–Verb–Subject)</li>
    </ul>
    <h3>Morphology</h3>
    <ul>
      <li>Consonant doubling for nouns: <code>man→mman</code></li>
      <li>Suffix mutations: <code>-ing→-enkh</code>, <code>-ed→-ethr</code>, <code>-ly→-lei</code></li>
      <li>Verb guttural ending: verbs gain <code>-akh</code></li>
    </ul>
    <h3>Articles</h3>
    <ul>
      <li>Articles (“the”, “a”, “an”) dropped in Revanant, restored as “the” in English</li>
    </ul>
    <h3>Possession</h3>
    <ul>
      <li>“of” replaced with <code>:</code> in Revanant, reversed back to “of”</li>
    </ul>
    <h3>Punctuation</h3>
    <ul>
      <li><code>.</code> → <code>¤</code></li>
      <li><code>,</code> → <code>~</code></li>
      <li><code>?</code> → <code>:?</code></li>
      <li><code>!</code> → <code>!!</code></li>
      <li><code>:</code> → <code>::</code></li>
      <li><code>;</code> → <code>;;</code></li>
    </ul>
    <h3>Round‑trip Guarantee</h3>
    <ul>
      <li>All rules are deterministic and reversible. English → Revanant → English returns the original sentence.</li>
    </ul>
  </div>

  <script>
    const vowelMap = { a:"au", e:"ei", i:"oi", o:"ou", u:"uu" };
    const revVowelOrder = ["uu","ou","oi","ei","au"];
    const revVowelMap = { "au":"a", "ei":"e", "oi":"i", "ou":"o", "uu":"u" };

    function mutateVowels(word) {
      return word.replace(/[aeiou]/gi, ch => {
        const isUpper = ch === ch.toUpperCase();
        const base = ch.toLowerCase();
        const rep = vowelMap[base] || base;
        return isUpper ? rep.toUpperCase() : rep;
      });
    }

    function reverseVowels(word) {
      let w = word;
      for (const dip of revVowelOrder) {
        const re = new RegExp(dip,"gi");
        w = w.replace(re, m => {
          const lower = revVowelMap[dip];
          return m === m.toUpperCase() ? lower.toUpperCase() : lower;
        });
      }
      return w;
    }

    function mutatePunctuationForward(text) {
      return text
        .replace(/\./g,"¤")
        .replace(/,/g,"~")
        .replace(/\?/g,":?")
        .replace(/!/g,"!!")
        .replace(/:/g,"::")
        .replace(/;/g,";;");
    }

    function mutatePunctuationReverse(text) {
      return text
        .replace(/¤/g,".")
        .replace(/~/g,",")
        .replace(/:\?/g,"?")
        .replace(/!!/g,"!")
        .replace(/::/g,":")
        .replace(/;;/g,";");
    }

    function tokenize(text) {
      return text.match(/[\w']+|[^\s\w]/g) || [];
    }

    function detokenize(tokens) {
      return tokens.map((t,i) => {
        if (/^[\.\,\!\?\:\;\)]$/.test(t)) return t;
        return (i===0 ? "" : " ") + t;
      }).join("");
    }

    function butcherForward(word) {
      let w = mutateVowels(word);

      if (/^(the|a|an)$/i.test(word)) return "";
      if (w.toLowerCase() === "of") return ":";

      if (/ing$/i.test(w)) w = w.replace(/ing$/i,"enkh");
      if (/ed$/i.test(w)) w = w.replace(/ed$/i,"ethr");
      if (/ly$/i.test(w)) w = w.replace(/ly$/i,"lei");

      if (/[kdnt]$/i.test(w)) w = w + "akh";

      if (!/[akh]$/.test(w) && /^[bcdfghjklmnpqrstvwxyz]/i.test(w)) {
        w = w[0]+w;
      }

      return w;
    }

    function butcherReverse(word) {
      let w = reverseVowels(word);

      if (w === ":") return "of";

      if (/enkh$/i.test(w)) w = w.replace(/enkh$/i,"ing");
      if (/ethr$/i.test(w)) w = w.replace(/ethr$/i,"ed");
      if (/lei$/i.test(w)) w = w.replace(/lei$/i,"ly");

      if (/akh$/i.test(w)) w = w.replace(/akh$/i,"");

      w = w.replace(/^([bcdfghjklmnpqrstvwxyz])\1/i,"$1");

      if (w === "") return "the";

      return w;
    }

    function englishToRevan(line) {
      line = mutatePunctuationForward(line);
      const tokens = tokenize(line);
      const words = tokens.filter(t => /\w/.test(t) || t === ":");
      const puncts = tokens.filter(t => !/\w/.test(t) && t !== ":");

      if (words.length < 2) {
        const out = tokens.map(t => /\w/.test(t) || t === ":" ? butcherForward(t) : t).filter(Boolean);
        return detokenize(out);
      }

      const subject = words[0];
      const verb = words[1];
      const object = words.slice(2);

      const mSubject = butcherForward(subject);
      const mVerb = butcherForward(verb);
      const mObject = object.map(butcherForward).filter(Boolean);

      const mutatedWords = [...mObject, mVerb, mSubject];
      const outTokens = [...mutatedWords, ...puncts];
      return detokenize(outTokens);
    }

    function revanToEnglish(line) {
      line = mutatePunctuationReverse(line);
      const tokens = tokenize(line);
      const words = tokens.filter(t => /\w/.test(t) || t === ":");
      const puncts = tokens.filter(t => !/\w/.test(t) && t !== ":");

      if (words.length < 2) {
        const